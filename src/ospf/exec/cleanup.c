/*
 * Copyright (C) 2012-2013 RCP100 Team (rcpteam@yahoo.com)
 *
 * This file is part of RCP100 project
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/
#include "ospf.h"
extern RcpPkt *pktout;
extern uint32_t redist_del_cnt;

uint32_t systic_delta_operation = 0;

static void clear_areas(void) {
	OspfArea *area = areaGetList();
	while (area) {
		lsadbAgeArea(area->area_id);
		OspfNetwork *net = area->network;
		while (net) {
			OspfNetwork *next = net->next;
			uint32_t ip = net->ip;

			netfsmInterfaceDown(net);
			rxMultiDropNetwork(rxsock, net);

			RcpInterface *intf = rcpFindInterface(shm, net->ip);
			if (intf && *intf->name != '\0') {
				intf->ospf_multicast_ip = 0;
				intf->ospf_multicast_mask = 0;
			}

			networkRemove(net->area_id, net);
			rcpLog(muxsock, RCP_PROC_OSPF, RLOG_INFO, RLOG_FC_INTERFACE,
				"network %d.%d.%d.%d deleted from area %u",
				RCP_PRINT_IP(ip), area->area_id);

			net = next;			
		}
		
		area->network = NULL;
		area->mylsa = NULL;
		lsadbRemoveArea(area->area_id);
		
		// copy over any new configuration
		area->router_id = shm->config.ospf_router_id;
		
		area = area->next;
	}
}

static void remove_areas(void) {
	while (1) {
		OspfArea *area = areaGetList();
		if (!area)
			break;
		areaRemove(area);
	}
}

static void clear_config() {
	memset(shm->config.ospf_area, 0, sizeof(shm->config.ospf_area));
	shm->config.ospf_router_id = 0;
	shm->config.ospf_spf_delay = RCP_OSPF_SPF_DELAY_DEFAULT;
	shm->config.ospf_spf_hold = RCP_OSPF_SPF_HOLD_DEFAULT;
	shm->config.ospf_log_adjacency = 0;
	shm->config.ospf_log_adjacency_detail = 0;
	redistClearShm();
	shm->stats.ospf_spf_calculations = 0;
	shm->stats.ospf_last_spf = 0;
	
}

static void clear_routes(void) {
	update_rt_start();
	update_rt_finish();
	rcpLog(muxsock, RCP_PROC_OSPF, RLOG_INFO, RLOG_FC_OSPF_SPF, "all OSPF routes deleted");
}

static void clear_external(void) {
	// remove any static lsa replaced by this
	flush_flooding();
	// remove static external lsa generated by us
	OspfLsa *lsa = lsadbGetList(0, LSA_TYPE_EXTERNAL);
	while (lsa != NULL) {
		OspfLsa *next = lsa->h.next;
		
		if (lsa->h.self_originated) {
			lsa->header.age = htons(MaxAge);
			lsadbFlood(lsa, 0);
			lsadbRemove(0, lsa);
			lsaFree(lsa);
			redist_del_cnt++;
		}
		
		lsa = next;
	}
	flush_flooding();
}
//******************************************************************
// configuration
//******************************************************************
int cliNoRouterOspfCmd(CliMode mode, int argc, char **argv) {
	struct tms tm;
	uint32_t tic1 = times(&tm);

	char *data = (char *) pktout + sizeof(RcpPkt);
	*data = '\0';
	
	// clear all configuration
	clear_config();
	
	// clear areas
	clear_areas();
	
	// remove areas
	remove_areas();
	
	// clear routes
	clear_routes();
	
	// remove summary addresses
	memset(shm->config.ospf_sum_addr, 0, sizeof(RcpOspfSummaryAddr) * RCP_OSPF_SUMMARY_ADDR_LIMIT);
	shm->config.ospf_discard_external = 1;
	
	// range
	memset(shm->config.ospf_range, 0, sizeof(RcpOspfRange) * RCP_OSPF_RANGE_LIMIT);
	shm->config.ospf_discard_internal = 1;
	
	// remove all external lsa
	clear_external();
	

	uint32_t tic2 = times(&tm);
	uint32_t delta;
	if (tic2 > tic1)
		delta = tic2 - tic1;
	else
		delta = tic1 - tic2;
	
	if (delta > systic_delta_operation) {
		systic_delta_operation = delta;
		rcpDebug("operation timeout delta %u\n", systic_delta_operation);
	}
		
	return 0;
}

//***************************************************************
// operation
//***************************************************************
int cliClearIpOspfCmd(CliMode mode, int argc, char **argv) {
	struct tms tm;
	uint32_t tic1 = times(&tm);

	char *data = (char *) pktout + sizeof(RcpPkt);
	*data = '\0';

	// clear areas
	clear_areas();

	// clear routes
	clear_routes();
	// delete any remaining ospf routes
	int v = system("/opt/rcp/bin/rtclean ospf");
	if (v == -1)
		ASSERT(0);
	
	spfTrigger();

	uint32_t tic2 = times(&tm);
	uint32_t delta;
	if (tic2 > tic1)
		delta = tic2 - tic1;
	else
		delta = tic1 - tic2;
	
	if (delta > systic_delta_operation) {
		systic_delta_operation = delta;
		rcpDebug("operation timeout delta %u\n", systic_delta_operation);
	}
	
	// schedule a request for rip routes in 5 seconds
	request_rip = 5;
	
	return 0;
}

//******************************************************************
// debug
//******************************************************************
int cliDebugOspfShutdown(CliMode mode, int argc, char **argv) {
	struct tms tm;
	uint32_t tic1 = times(&tm);

	char *data = (char *) pktout + sizeof(RcpPkt);
	*data = '\0';

	// clear areas
	clear_areas();
	
	// remove areas
	remove_areas();
	
	// clear routes
	clear_routes();

	force_shutdown = 1;	

	uint32_t tic2 = times(&tm);
	uint32_t delta;
	if (tic2 > tic1)
		delta = tic2 - tic1;
	else
		delta = tic1 - tic2;
	
	if (delta > systic_delta_operation) {
		systic_delta_operation = delta;
		rcpDebug("operation timeout delta %u\n", systic_delta_operation);
	}
	return 0;
}

