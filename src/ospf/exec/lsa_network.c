/*
 * Copyright (C) 2012-2013 RCP100 Team (rcpteam@yahoo.com)
 *
 * This file is part of RCP100 project
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/
#include "ospf.h"

//************************************************************************
// Network LSA
//************************************************************************
// return 0 if identical
static int cmp_net_lsa(OspfLsa *lsa1, OspfLsa *lsa2) {
	if (lsa1 == NULL || lsa2 == NULL) {
		ASSERT(0);
		return 1;
	}
	
	OspfLsaHeader *lsah1 = &lsa1->header;
	OspfLsaHeader *lsah2 = &lsa2->header;

	if (lsah1->options != lsah1->options ||
	    lsah1->type !=  lsah2->type ||
	    lsah1->link_state_id !=  lsah2->link_state_id ||
	    lsah1->adv_router !=  lsah2->adv_router ||
	    lsah1->length != lsah2->length)
	  	return 1;

	NetLsaData *ndata1 = &lsa1->u.net;
	NetLsaData *ndata2 = &lsa2->u.net;
	return memcmp(ndata1, ndata2, ntohs(lsah1->length) - sizeof(OspfLsaHeader));
}


// originate a network lsa
OspfLsa *lsa_originate_net(OspfNetwork *net) {
	TRACE_FUNCTION();
	ASSERT(net != NULL);
	ASSERT(net->state == NETSTATE_DR || net->designated_router == net->ip);

	// ofiginate the network if we have at least one neighbor FULL
	// count neighbors in this area
	int cnt = 0;
	OspfNeighbor *nb = net->neighbor;
	while (nb != NULL) {
		if (nb->state == NSTATE_FULL)
			cnt++;
		nb = nb->next;
	}
	if (!cnt)
		return NULL;

	// try to find if we already have this lsa
	OspfLsa *lsa = lsadbFind(net->area_id, 2, htonl(net->ip), htonl(net->router_id));
	int replace_it = 0;
	if (lsa && lsa->h.self_originated) {
		// looks like we already have an lsa, set replace flag
		replace_it = 1;
	}
	
	// calculate total length
	int size = sizeof(OspfLsa) + sizeof(NetLsaData);

	cnt++;	// count this network also
	size += cnt * sizeof(uint32_t);
	
	
	// allocate lsa
	OspfLsa *rv = malloc(size);
	if (rv == NULL) {
		printf("   lsadb: cannot allocate memory\n");
		exit(1);
	}
	memset(rv, 0, size);
	rv->h.size = size;
	rv->h.self_originated = 1;
	
	// fill in the header
	OspfLsaHeader *lsah = &rv->header;
	lsah->age = 0;
	lsah->options = 2; //E bit
	lsah->type = 2;
	lsah->link_state_id = htonl(net->ip);
	lsah->adv_router = htonl(net->router_id);
	lsah->seq = htonl(seq_number);
	lsa_increment_seq();
	lsah->length = htons(sizeof(OspfLsaHeader) + sizeof(NetLsaData) + cnt * sizeof(uint32_t));
	
	// set net
	NetLsaData *rdata = &rv->u.net;
	rdata->mask = htonl(net->mask);
	
	// bring in the neighbors
	uint32_t *nbip = (uint32_t *) ((uint8_t *) rdata + sizeof(NetLsaData));
	nb = net->neighbor;
	while (nb != NULL) {
		if (nb->state == NSTATE_FULL) {
			*nbip = htonl(nb->router_id);
			nbip++;
		}
		nb = nb->next;
	}
	*nbip = htonl(net->router_id);

	// calculate checksum
	lsah = &rv->header;
	uint8_t *msg = (uint8_t *) lsah + 2;
	int sz = ntohs(lsah->length) - 2;
	fletcher16(msg, sz, 15);

	if (replace_it) {
		// compare the old lsa with the new one
		if (cmp_net_lsa(rv, lsa) == 0) {
			// same lsa different age and seq
			// free new lsa
			free(rv);
			lsa->h.del_flag = 0;
			return NULL;
		}

		// remove existing lsa
		lsaListRemove(lsadbGetListHead(net->area_id, lsa->header.type), lsa);
		lsaFree(lsa);
	}
	else
		trap_OriginateLsa(rv, net->area_id);

	rcpLog(muxsock, RCP_PROC_OSPF, RLOG_DEBUG, RLOG_FC_OSPF_LSA,
		"area %u, originated LSA %d.%d.%d.%d, type %d, seq 0x%x",
		net->area_id,
		RCP_PRINT_IP(ntohl(lsah->link_state_id)),
		lsah->type,
		ntohl(lsah->seq));

	rv->h.flood = 1;
	rv->h.del_flag = 0;
	return rv;
}


void lsa_originate_net_update(void) {
	OspfArea *area = areaGetList();
	// set the delete flag in all network lsa generated by us
	while (area) {
		OspfLsa *lsa = lsadbGetList(area->area_id, LSA_TYPE_NETWORK);
		while (lsa != NULL) {
			if (lsa->h.self_originated) 
				lsa->h.del_flag = 1;
			lsa = lsa->h.next;
		}
		
		area = area->next;
	}

	area = areaGetList();
	// update all network lsa
	while (area) {
		OspfNetwork *net = area->network;
		while (net) {
			if (net->state == NETSTATE_DR) {
				OspfLsa *lsa = lsa_originate_net(net);
				if (lsa != NULL)
					lsadbAdd(net->area_id, lsa);
			}
			
			net = net->next;
		}
		
		area = area->next;
	}

	// age lsa with a del_flag set
	area = areaGetList();
	while (area) {
		OspfLsa *lsa = lsadbGetList(area->area_id, LSA_TYPE_NETWORK);
		while (lsa != NULL) {
			OspfLsa *next = lsa->h.next;

			if (lsa->h.del_flag == 1) {
				lsa->header.age = htons(MaxAge);
				lsadbFlood(lsa, area->area_id);
				lsadbRemove(area->area_id, lsa);
				lsaFree(lsa);
			}
			lsa = next;
		}
		
		area = area->next;
	}
}

